

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>PEEPHOLE: indirect memory access from host &mdash; envytools git documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     'git',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="envytools git documentation" href="../index.html" />
    <link rel="up" title="Memory access and structure" href="index.html" />
    <link rel="next" title="PFB: NV44:NV50 TURBOCACHE memory controller" href="nv40-pfb.html" />
    <link rel="prev" title="PFB: NV10:NV40 memory controller" href="nv10-pfb.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="nv40-pfb.html" title="PFB: NV44:NV50 TURBOCACHE memory controller"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="nv10-pfb.html" title="PFB: NV10:NV40 memory controller"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">envytools git documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Memory access and structure</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="peephole-indirect-memory-access-from-host">
<span id="peephole"></span><h1><a class="toc-backref" href="#id1">PEEPHOLE: indirect memory access from host</a><a class="headerlink" href="#peephole-indirect-memory-access-from-host" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#peephole-indirect-memory-access-from-host" id="id1">PEEPHOLE: indirect memory access from host</a><ul>
<li><a class="reference internal" href="#introduction" id="id2">Introduction</a></li>
<li><a class="reference internal" href="#mmio-registers" id="id3">MMIO registers</a></li>
<li><a class="reference internal" href="#write-port" id="id4">Write port</a></li>
<li><a class="reference internal" href="#rw-port-operation" id="id5">RW port operation</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id2">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>PEEPHOLE is a mechanism to indirectly access memory form the CPU. It is
present on NV30+ cards. On NV30:NV50, it accesses physical [unpaged] VRAM.
On NV50+, it can access either physical VRAM, or virtual [paged] memory via
standard VM circuitry. Additionally, on NV84+, the PEEPHOLE MMIO registers
are stuffed into a dedicated range [0x060000:0x061000], so that the driver
can allow userspace programs access to the PEEPHOLE and nothing else.</p>
<p>PEEPHOLE is part of PBUS and thus not affected by any PMC.ENABLE bit. The
actual memory access is handled by PFIFO on NV50+ cards.</p>
<p>The PEEPHOLE has two ports: a write-only port and a read-write port. The ports
share a common VM context on NV50+, but are otherwise independent. The
write-only port is only present on NV30:NVC0.</p>
<p>The addresses used for PEEPHOLE accesses have to be 4-byte aligned, and the
window for indirect access is 4 bytes long. The addresses are 29-bit on
NV30:NV50 [enough to address all of VRAM], 32-bit on NV50:NVC0, 40-bit on
NVC0+.</p>
<p>For details on setting up the target physical/VM space on NV50:NVC0, see
<a class="reference internal" href="nv50-host-mem.html#nv50-host-mem"><em>NV50:NVC0 host memory interface</em></a>; for NVC0+ see <a class="reference internal" href="nvc0-host-mem.html#nvc0-host-mem"><em>NVC0- host memory interface</em></a>.</p>
<p>Note that, on NV30:NVC0 cards, the PEEPHOLE is subject to PMC hidden window
masking - see <a class="reference internal" href="../bus/pmc.html#pmc-vram-hide"><em>VRAM hidden area</em></a> for details.</p>
</div>
<div class="section" id="mmio-registers">
<span id="peephole-mmio"></span><h2><a class="toc-backref" href="#id3">MMIO registers</a><a class="headerlink" href="#mmio-registers" title="Permalink to this headline">¶</a></h2>
<p>The following MMIO registers deal with PEEPHOLE:</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="10%" />
<col width="21%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Address</th>
<th class="head">Present on</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x00155c</td>
<td>NV30:NVC0</td>
<td>PEEPHOLE_W_CTRL</td>
<td><a class="reference internal" href="#peephole-mmio-w"><em>write port control</em></a></td>
</tr>
<tr class="row-odd"><td>0x001560</td>
<td>NV30:NV84</td>
<td>PEEPHOLE_W_ADDR</td>
<td><a class="reference internal" href="#peephole-mmio-w"><em>write port address</em></a></td>
</tr>
<tr class="row-even"><td>0x001564</td>
<td>NV30:NV84</td>
<td>PEEPHOLE_W_DATA</td>
<td><a class="reference internal" href="#peephole-mmio-w"><em>write port data</em></a></td>
</tr>
<tr class="row-odd"><td>0x001570</td>
<td>NV30:NV84</td>
<td>PEEPHOLE_RW_ADDR</td>
<td><a class="reference internal" href="#peephole-mmio-rw"><em>read-write port address</em></a></td>
</tr>
<tr class="row-even"><td>0x001574</td>
<td>NV30:NV84</td>
<td>PEEPHOLE_RW_DATA</td>
<td><a class="reference internal" href="#peephole-mmio-rw"><em>read-write port data</em></a></td>
</tr>
<tr class="row-odd"><td>0x060000</td>
<td>NV84:NVC0</td>
<td>PEEPHOLE_W_ADDR</td>
<td><a class="reference internal" href="#peephole-mmio-w"><em>write port address</em></a></td>
</tr>
<tr class="row-even"><td>0x060004</td>
<td>NV84:NVC0</td>
<td>PEEPHOLE_W_DATA</td>
<td><a class="reference internal" href="#peephole-mmio-w"><em>write port data</em></a></td>
</tr>
<tr class="row-odd"><td>0x06000c</td>
<td>NVC0-</td>
<td>PEEPHOLE_RW_ADDR_HIGH</td>
<td><a class="reference internal" href="#peephole-mmio-rw"><em>read-write port address, high part</em></a></td>
</tr>
<tr class="row-even"><td>0x060010</td>
<td>NV84-</td>
<td>PEEPHOLE_RW_ADDR_LOW</td>
<td><a class="reference internal" href="#peephole-mmio-rw"><em>read-write port address, low part</em></a></td>
</tr>
<tr class="row-odd"><td>0x060014</td>
<td>NV84-</td>
<td>PEEPHOLE_RW_DATA</td>
<td><a class="reference internal" href="#peephole-mmio-rw"><em>read-write port data</em></a></td>
</tr>
</tbody>
</table>
<p>In addition, PEEPHOLE uses PBUS interrupt #12 for its write port.</p>
</div>
<div class="section" id="write-port">
<span id="peephole-mmio-w"></span><span id="pbus-intr-peephole-w-pair-mismatch"></span><h2><a class="toc-backref" href="#id4">Write port</a><a class="headerlink" href="#write-port" title="Permalink to this headline">¶</a></h2>
<p>Write port is present on NV30:NVC0 cards only. The write port consists of
an address register, a data register, and a control register. It can operate
in two modes:</p>
<ul class="simple">
<li>paired write mode: The address and data registers are supposed to be
accessed by two back-to-back writes, in either order. The back-to-back
write is supposed to be generated by software doing a 64-bit write on the
address covering both of these registers. Writing these registers in any
other way, or doing any other MMIO write between the writes, is an error
and will cause an interrupt. The memory write will be performed on the
second write of the pair.</li>
<li>freeform mode: both registers can be accessed in any manner, any write
to the data register will perform a memory write.</li>
</ul>
<p>The mode of operation and current status can be read/written via the
PEEPHOLE_W_CTRL register:</p>
<dl class="docutils">
<dt>MMIO 0x00155c: PEEPHOLE_W_CTRL [NV30:NVC0]</dt>
<dd><ul class="first last simple">
<li>bit 0: PAIR_ADDR_VALID - 1 when an address write has been performed, and the
hw is waiting for a data write</li>
<li>bit 1: PAIR_DATA_VALID - 1 when a data write has been performed, and the hw
is waiting for an address write</li>
<li>bit 8: MODE<ul>
<li>0: PAIR - selects paired write mode</li>
<li>1: FREEFORM - selects freeform mode</li>
</ul>
</li>
</ul>
</dd>
</dl>
<p>The address and data registers are:</p>
<p>MMIO 0x001560: PEEPHOLE_W_ADDR [NV30:NV84]
MMIO 0x060000: PEEPHOLE_W_ADDR [NV84:NVC0]</p>
<blockquote>
<div>The address register. On NV30:NV50, only bits 2-28 are valid. On NV50+, only
bits 2-31 are valid.</div></blockquote>
<p>MMIO 0x001564: PEEPHOLE_W_DATA [NV30:NV84]
MMIO 0x060004: PEEPHOLE_W_DATA [NV84:NVC0]</p>
<blockquote>
<div>The data register. This register is actually RW, and a read will return the
last written value. Writes other than 32-bit are accepted, but will translate
to appropriately-sized memory writes <em>only if the memory write is triggered
by the data register write</em> - if the memory write is triggered by address
register write, a 32-bit memory write will be performed instead, with junk
in the remaining bytes.</div></blockquote>
<p>PEEPHOLE_W_ADDR write operation:</p>
<div class="highlight-python"><pre>PEEPHOLE_W_ADDR = value;
if (MODE == PAIR) {
        if (PAIR_ADDR_VALID) {
                raise_irq(PBUS.INTR.PEEPHOLE_W_PAIR_MISMATCH);
        } else if (PAIR_DATA_VALID) {
                peephole_write32(PEEPHOLE_W_ADDR, PEEPHOLE_W_DATA);
                PAIR_DATA_VALID = 0;
        } else {
                PAIR_ADDR_VALID = 1;
        }
}</pre>
</div>
<p>PEEPHOLE_W_DATA write operation:</p>
<div class="highlight-python"><pre>PEEPHOLE_W_DATA = value;
if (MODE == PAIR) {
        if (PAIR_DATA_VALID) {
                raise_irq(PBUS.INTR.PEEPHOLE_W_PAIR_MISMATCH);
        } else if (PAIR_ADDR_VALID) {
                peephole_write_be(PEEPHOLE_W_ADDR, value, value_be); /* memory write byte enables copied from the MMIO access */
                PAIR_ADDR_VALID = 0;
        } else {
                PAIR_DATA_VALID = 1;
        }
} else {
        peephole_write_be(PEEPHOLE_W_ADDR, value, value_be); /* memory write byte enables copied from the MMIO access */
}</pre>
</div>
<p>The PEEPHOLE_W_PAIR_MISMATCH interrupt is reported in
<a class="reference internal" href="../bus/pbus.html#pbus-intr"><em>PBUS.INTR bit 12</em></a>.</p>
</div>
<div class="section" id="rw-port-operation">
<span id="peephole-mmio-rw"></span><h2><a class="toc-backref" href="#id5">RW port operation</a><a class="headerlink" href="#rw-port-operation" title="Permalink to this headline">¶</a></h2>
<p>The RW port is available on all NV30+ cards. There is an address register and
a data register. Accesses to the address register merely read/write that
register. All accesses to the data register are translated to equivalent
memory accesses at the address selected by the address register, and cause
the address register to auto-increment by 4. The translation preserves byte
enables, thus it&#8217;s possible to do accesses smaller than 32 bits [though the
address will always autoincrement by 4].</p>
<dl class="docutils">
<dt>MMIO 0x06000c: PEEPHOLE_RW_ADDR_HIGH [NVC0-]</dt>
<dd>The high part of the address register - bits 0-7 are valid and correspond to
address bits 32-39.</dd>
</dl>
<p>MMIO 0x001570: PEEPHOLE_RW_ADDR [NV30:NV84]
MMIO 0x060010: PEEPHOLE_RW_ADDR_LOW [NV84-]</p>
<blockquote>
<div>The low part of the address register. On NV30:NV50, only bits 2-28 are
valid. On NV50+, only bits 2-31 are valid.</div></blockquote>
<p>MMIO 0x001574: PEEPHOLE_RW_DATA [NV30:NV84]
MMIO 0x060014: PEEPHOLE_RW_DATA [NV84-]</p>
<blockquote>
<div>The data port. Any access to this address will be translated to
a corresponding memory read/write and cause the address register to be
autoincremented by 4. On NVC0+, the carry from LOW to HIGH is handled
properly.</div></blockquote>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">PEEPHOLE: indirect memory access from host</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#mmio-registers">MMIO registers</a></li>
<li><a class="reference internal" href="#write-port">Write port</a></li>
<li><a class="reference internal" href="#rw-port-operation">RW port operation</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="nv10-pfb.html"
                        title="previous chapter">PFB: NV10:NV40 memory controller</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="nv40-pfb.html"
                        title="next chapter">PFB: NV44:NV50 TURBOCACHE memory controller</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/memory/peephole.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="nv40-pfb.html" title="PFB: NV44:NV50 TURBOCACHE memory controller"
             >next</a> |</li>
        <li class="right" >
          <a href="nv10-pfb.html" title="PFB: NV10:NV40 memory controller"
             >previous</a> |</li>
        <li><a href="../index.html">envytools git documentation</a> &raquo;</li>
          <li><a href="index.html" >Memory access and structure</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Marcin Kościelnicki.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>